<H3>231128_Stack</H3>
스택을 연결리스트를 이용해서 구현을 해보았음.
단, 언어에 따라 스택을 연결리스트가 아니라 배열을 이용하여 구현하는 경우도 있음.
백준 28278번을 풀 때는 Next 링크(포인터)를 이용하여 Node 내에 Node를 정의하다보니
연결리스트의 개념이 들어갔다고 볼 수 있음.

배열을 이용한 방법도 해볼 것.

<H3>231128_Queue</H3>
이중 연결리스트이 개념을 활용한 큐 구현.
기존의 연결리스트는 Next 포인터만 있었다면, 이중 연결리스트는 이전을 의미하는 Prev 포인터도
지정을 해줘서 각 노드가 앞 뒤를 가리키도록 하여 Dequeue를 할 때, O(1)의 성능을 내도록 하는 것이 핵심.

<H3>231129_Deque</H3>
이중 연결리스트이 개념을 활용한 데크 구현.
이중 연결리스트를 미리 구현해두었으므로, 데크자체는 맨뒤 삽입 및 삭제, 맨앞 삽입 및 삭제 정도의 기능만
추가하는 것으로 간단하게 구현이 가능하였음.

<H3>231130_HashTable</H3>
키, 값 쌍으로 자료를 저장하는 방법으로 이중 연결리스트를 통해서 구현을 했음.<br/>
해시테이블을 정의할 때, 해시 함수에 의해 같은 인덱스에 해당하는 값들은 최악의 경우 탐색 성능이 <br/>
O(n)의 성능을 갖도록 하게 구현됨.<br/>

해시테이블의 특징
- 장점 : 빠른 데이터 읽기, 삽입, 삭제가 가능
- 단점 : 메모리를 많이 차지함 (미리 배열을 선언해두므로), 좋은 해시함수 구현이 필수적임.
         해시 충돌이 일어날 수 있음.

여기서 좋은 해시함수는 충돌을 덜 일으키는 해시함수라고 볼 수 있음. 이를 simple uniform hashing을 만족한다고 함.<br/>
simple : 각각의 key가 중복없이 m개의 슬롯으로 동일한 확률로 분배된다.<br/>
uniform : : 각각의 key는 다른 key값이 해시값과 관계없이 해시되는것. 충돌을 최소화 하는것임.<br/>
따라서, m개의 슬롯이 있을 때, 중복이 최소화되어 m개의 slot에 골고루 분배되는것이 좋은 해시함수임.<br/>
==> 나의 생각 : 비둘기집 원리에 의해 슬롯보다 넣어야할 값들이 더 많으면 무조건 어딘가에서 2개이상 분배가 됨.<br/>
                이때 생각해 볼 수 있는 것은, 메모리 소모가 좀 더 크더라도 슬롯을 더 늘리고 그에 맞는 해시함수를 더 짜주는게 좋을지에 대한 고민,<br/>
                현재의 해시함수가 분배를 잘 해주고 있는지 (어딘가로 몰아서 삽입되는 방식은 아닌지)를 확인해야 할 것 같다.<br/>
